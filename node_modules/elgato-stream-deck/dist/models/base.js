"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const HID = require("node-hid");
const util_1 = require("../util");
class StreamDeckBase extends events_1.EventEmitter {
    get NUM_KEYS() {
        return this.KEY_COLUMNS * this.KEY_ROWS;
    }
    get KEY_COLUMNS() {
        return this.deviceProperties.COLUMNS;
    }
    get KEY_ROWS() {
        return this.deviceProperties.ROWS;
    }
    get ICON_SIZE() {
        return this.deviceProperties.ICON_SIZE;
    }
    get ICON_BYTES() {
        return this.ICON_SIZE * this.ICON_SIZE * 3;
    }
    get MODEL() {
        return this.deviceProperties.MODEL;
    }
    constructor(deviceInfo, properties, dataKeyOffset) {
        super();
        this.deviceProperties = properties;
        this.device = new HID.HID(deviceInfo.path);
        this.keyState = new Array(this.NUM_KEYS).fill(false);
        this.device.on('data', data => {
            // The first byte is a report ID, the last byte appears to be padding.
            // We strip these out for now.
            data = data.slice(dataKeyOffset, data.length - 1);
            for (let i = 0; i < this.NUM_KEYS; i++) {
                const keyPressed = Boolean(data[i]);
                const keyIndex = this.transformKeyIndex(i);
                const stateChanged = keyPressed !== this.keyState[keyIndex];
                if (stateChanged) {
                    this.keyState[keyIndex] = keyPressed;
                    if (keyPressed) {
                        this.emit('down', keyIndex);
                    }
                    else {
                        this.emit('up', keyIndex);
                    }
                }
            }
        });
        this.device.on('error', err => {
            this.emit('error', err);
        });
    }
    fillColor(keyIndex, r, g, b) {
        this.checkValidKeyIndex(keyIndex);
        this.checkRGBValue(r);
        this.checkRGBValue(g);
        this.checkRGBValue(b);
        const pixels = Buffer.alloc(this.ICON_BYTES, Buffer.from([r, g, b]));
        const keyIndex2 = this.transformKeyIndex(keyIndex);
        this.fillImageRange(keyIndex2, pixels, 0, this.ICON_SIZE * 3);
    }
    fillImage(keyIndex, imageBuffer) {
        this.checkValidKeyIndex(keyIndex);
        if (imageBuffer.length !== this.ICON_BYTES) {
            throw new RangeError(`Expected image buffer of length ${this.ICON_BYTES}, got length ${imageBuffer.length}`);
        }
        const keyIndex2 = this.transformKeyIndex(keyIndex);
        this.fillImageRange(keyIndex2, imageBuffer, 0, this.ICON_SIZE * 3);
    }
    fillPanel(imageBuffer) {
        if (imageBuffer.length !== this.ICON_BYTES * this.NUM_KEYS) {
            throw new RangeError(`Expected image buffer of length ${this.ICON_BYTES * this.NUM_KEYS}, got length ${imageBuffer.length}`);
        }
        for (let row = 0; row < this.KEY_ROWS; row++) {
            for (let column = 0; column < this.KEY_COLUMNS; column++) {
                let index = row * this.KEY_COLUMNS;
                if (this.deviceProperties.KEY_DIRECTION === 'ltr') {
                    index += column;
                }
                else {
                    index += this.KEY_COLUMNS - column - 1;
                }
                const stride = this.ICON_SIZE * 3 * this.KEY_COLUMNS;
                const rowOffset = stride * row * this.ICON_SIZE;
                const colOffset = column * this.ICON_SIZE * 3;
                this.fillImageRange(index, imageBuffer, rowOffset + colOffset, stride);
            }
        }
    }
    clearKey(keyIndex) {
        this.checkValidKeyIndex(keyIndex);
        return this.fillColor(keyIndex, 0, 0, 0);
    }
    clearAllKeys() {
        // TODO - this could be restructured to be more efficient (by reusing the final colour buffer)
        for (let keyIndex = 0; keyIndex < this.NUM_KEYS; keyIndex++) {
            this.clearKey(keyIndex);
        }
    }
    setBrightness(percentage) {
        if (percentage < 0 || percentage > 100) {
            throw new RangeError('Expected brightness percentage to be between 0 and 100');
        }
        // prettier-ignore
        const brightnessCommandBuffer = [
            0x05, 0x55, 0xaa, 0xd1, 0x01, percentage, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00
        ];
        this.device.sendFeatureReport(brightnessCommandBuffer);
    }
    resetToLogo() {
        // prettier-ignore
        const resetCommandBuffer = [
            0x0B, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00
        ];
        this.device.sendFeatureReport(resetCommandBuffer);
    }
    getFirmwareVersion() {
        return util_1.numberArrayToString(this.device.getFeatureReport(4, 17).slice(5));
    }
    getSerialNumber() {
        return util_1.numberArrayToString(this.device.getFeatureReport(3, 17).slice(5));
    }
    getFillImageCommandHeaderLength() {
        return 16;
    }
    writeFillImageCommandHeader(buffer, keyIndex, partIndex, isLast, _bodyLength) {
        buffer.writeUInt8(0x02, 0);
        buffer.writeUInt8(0x01, 1);
        buffer.writeUInt16LE(partIndex, 2);
        // 3 = 0x00
        buffer.writeUInt8(isLast ? 1 : 0, 4);
        buffer.writeUInt8(keyIndex + 1, 5);
    }
    generateFillImageWrites(keyIndex, byteBuffer) {
        const MAX_PACKET_SIZE = this.getFillImagePacketLength();
        const PACKET_HEADER_LENGTH = this.getFillImageCommandHeaderLength();
        const MAX_PAYLOAD_SIZE = MAX_PACKET_SIZE - PACKET_HEADER_LENGTH;
        const result = [];
        let remainingBytes = byteBuffer.length;
        for (let part = 0; remainingBytes > 0; part++) {
            const packet = Buffer.alloc(MAX_PACKET_SIZE);
            const byteCount = Math.min(remainingBytes, MAX_PAYLOAD_SIZE);
            this.writeFillImageCommandHeader(packet, keyIndex, part, remainingBytes <= MAX_PAYLOAD_SIZE, byteCount);
            const byteOffset = byteBuffer.length - remainingBytes;
            remainingBytes -= byteCount;
            byteBuffer.copy(packet, PACKET_HEADER_LENGTH, byteOffset, byteOffset + byteCount);
            result.push(util_1.bufferToIntArray(packet));
        }
        return result;
    }
    fillImageRange(keyIndex, imageBuffer, sourceOffset, sourceStride) {
        this.checkValidKeyIndex(keyIndex);
        const byteBuffer = this.convertFillImage(imageBuffer, sourceOffset, sourceStride);
        const packets = this.generateFillImageWrites(keyIndex, byteBuffer);
        for (const packet of packets) {
            this.device.write(packet);
        }
    }
    checkValidKeyIndex(keyIndex) {
        if (keyIndex < 0 || keyIndex >= this.NUM_KEYS) {
            throw new TypeError(`Expected a valid keyIndex 0 - ${this.NUM_KEYS - 1}`);
        }
    }
    checkRGBValue(value) {
        if (value < 0 || value > 255) {
            throw new TypeError('Expected a valid color RGB value 0 - 255');
        }
    }
}
exports.StreamDeckBase = StreamDeckBase;
